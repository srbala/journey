[{"configDocKey":{"type":"string","key":"quarkus.quartz.instance-name","configDoc":"The name of the Quartz instance.","withinAMap":false,"defaultValue":"QuarkusQuartzScheduler","javaDocSiteLink":"","docMapKey":"instance-name","configPhase":"RUN_TIME","acceptedValues":null,"optional":false,"list":false,"passThroughMap":false,"withinAConfigGroup":false,"topLevelGrouping":"quarkus.quartz","enum":false}},{"configDocKey":{"type":"int","key":"quarkus.quartz.thread-count","configDoc":"The size of scheduler thread pool. This will initialize the number of worker threads in the pool.","withinAMap":false,"defaultValue":"25","javaDocSiteLink":"","docMapKey":"thread-count","configPhase":"RUN_TIME","acceptedValues":null,"optional":false,"list":false,"passThroughMap":false,"withinAConfigGroup":false,"topLevelGrouping":"quarkus.quartz","enum":false}},{"configDocKey":{"type":"int","key":"quarkus.quartz.thread-priority","configDoc":"Thread priority of worker threads in the pool.","withinAMap":false,"defaultValue":"5","javaDocSiteLink":"","docMapKey":"thread-priority","configPhase":"RUN_TIME","acceptedValues":null,"optional":false,"list":false,"passThroughMap":false,"withinAConfigGroup":false,"topLevelGrouping":"quarkus.quartz","enum":false}},{"configDocKey":{"type":"java.time.Duration","key":"quarkus.quartz.misfire-threshold","configDoc":"Defines how late the schedulers should be to be considered misfired.","withinAMap":false,"defaultValue":"60S","javaDocSiteLink":"https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html","docMapKey":"misfire-threshold","configPhase":"RUN_TIME","acceptedValues":null,"optional":false,"list":false,"passThroughMap":false,"withinAConfigGroup":false,"topLevelGrouping":"quarkus.quartz","enum":false}},{"configDocKey":{"type":"io.quarkus.quartz.runtime.QuartzStartMode","key":"quarkus.quartz.start-mode","configDoc":"Scheduler can be started in different modes: normal, forced or halted. By default, the scheduler is not started unless a `io.quarkus.scheduler.Scheduled` business method is found. If set to \"forced\", scheduler will be started even if no scheduled business methods are found. This is necessary for \"pure\" programmatic scheduling. Additionally, setting it to \"halted\" will behave just like forced mode but the scheduler will not start triggering jobs until an explicit start is called from the main scheduler. This is useful to programmatically register listeners before scheduler starts performing some work.","withinAMap":false,"defaultValue":"normal","javaDocSiteLink":"","docMapKey":"start-mode","configPhase":"RUN_TIME","acceptedValues":["`normal`","`forced`","`halted`"],"optional":false,"list":false,"passThroughMap":false,"withinAConfigGroup":false,"topLevelGrouping":"quarkus.quartz","enum":true}},{"configDocSection":{"name":"quarkus.quartz.misfire-policy-per-jobs","optional":false,"withinAMap":false,"sectionDetails":"= Misfire policy per job configuration","sectionDetailsTitle":"Misfire policy per job configuration","configPhase":"RUN_TIME","topLevelGrouping":"quarkus.quartz","configGroupType":"io.quarkus.quartz.runtime.QuartzRuntimeConfig.QuartzMisfirePolicyConfig","showSection":true,"configDocItems":[{"configDocKey":{"type":"io.quarkus.quartz.runtime.QuartzMisfirePolicy","key":"quarkus.quartz.misfire-policy.\"identity\"","configDoc":"The quartz misfire policy for this job.","withinAMap":true,"defaultValue":"smart-policy","javaDocSiteLink":"","docMapKey":"misfire-policy","configPhase":"RUN_TIME","acceptedValues":["`smart-policy`","`ignore-misfire-policy`","`fire-now`","`simple-trigger-reschedule-now-with-existing-repeat-count`","`simple-trigger-reschedule-now-with-remaining-repeat-count`","`simple-trigger-reschedule-next-with-remaining-count`","`simple-trigger-reschedule-next-with-existing-count`","`cron-trigger-do-nothing`"],"optional":false,"list":false,"passThroughMap":false,"withinAConfigGroup":true,"topLevelGrouping":"quarkus.quartz","enum":true}}],"anchorPrefix":null}}]